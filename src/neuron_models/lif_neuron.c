#include "snn_library.h"
#include "neuron_models/lif_neuron.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>


void lif_neuron_compute_input_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    lif_neuron_t *lif_neuron;
    int i, next_spike_time, synapse_index; 
    synapse_t *synapse;
    double input_current = 0;


    // get neuron to be processed
    lif_neuron = &(snn->lif_neurons[neuron_id]);
    

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // process neuron if not in refractory period
    if(lif_neuron->r_time_rest <= 0){ 
        // loop over input synapses
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            // get synapse from synapse array
            synapse_index = lif_neuron->input_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]);


            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            // get the time step of the next spike to be processed
            next_spike_time = synapse->l_spike_times[synapse->next_spike];

            // refresh index // TODO: revise this
            while (next_spike_time < t && synapse->next_spike != synapse->last_spike){
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
                next_spike_time = synapse->l_spike_times[synapse->next_spike];
            }

            // process input spike if required
            if(next_spike_time == t){
                
                // sum weight to input current to next update the membrane potential
                input_current += synapse->w;

                // update next spike index
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        // compute membrane potential --> https://colab.research.google.com/github/johanjan/MOOC-HPFEM-source/blob/master/LIF_ei_balance_irregularity.ipynb
        //lif_neuron->v =  lif_neuron->v * (1 - 1 / 20) + input_current;  //(0.2) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current); // (1 / 5)
        lif_neuron->v = lif_neuron->v + (-(lif_neuron->v - lif_neuron->v_rest) + (lif_neuron->r * input_current)) * (1 / 1);
    }
}

void lif_neuron_compute_output_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    lif_neuron_t *lif_neuron;
    int i, next_spike_time, synapse_index;
    double input_current = 0;
    synapse_t *synapse;


    // get neuron to be processed
    lif_neuron = &(snn->lif_neurons[neuron_id]);

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // fire an spike if neuron membrane potential is higher than the threshold and neuron is not in refractory period
    if(lif_neuron->r_time_rest <= 0 && lif_neuron->v >= lif_neuron->v_tresh){

        #ifdef DEBUG
            printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
        #endif

        // send spike to all output synapses
        for(i = 0; i<lif_neuron->n_output_synapse; i++){
            
            // get synapse to add the new spike
            synapse_index = lif_neuron->output_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]);

            #ifdef DEBUG
                printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
            #endif

            // add the spike to output synapse
            synapse->l_spike_times[synapse->last_spike] = t + synapse->delay;
            synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes;
        }

        // update control information
        lif_neuron->t_last_spike = t; // last spike generated by the neuron
        lif_neuron->r_time_rest = lif_neuron->r_time; // set refractory time period
        lif_neuron->v = lif_neuron->v_reset; // reset potential

        // add information to results struct // TODO: This should be refactorized since this will be done for all neuron types
        results->generated_spikes[neuron_id][t] = '|'; // TODO: probably this should be a list of unsigned int, or bits, or something
        results->n_spikes_per_neuron[neuron_id] += 1; 
    }
    else{
        // no spike generated
        results->generated_spikes[neuron_id][t] = ' ';

        // refresh refractory period time
        lif_neuron->r_time_rest --; // the value can be lower than 0
    }
}

void lif_neuron_step(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    lif_neuron_t *lif_neuron;
    int i, next_spike_time, synapse_index;
    double input_current = 0;
    synapse_t *synapse;

    lif_neuron = &(snn->lif_neurons[neuron_id]);

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif


    // process neuron if not in refractory period
    if(lif_neuron->r_time_rest <= 0){ 
        
        // loop over input synapses
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            // get synapse from synapse array
            synapse_index = lif_neuron->input_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]);


            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            // get the time step of the next spike to be processed
            next_spike_time = synapse->l_spike_times[synapse->next_spike];

            // refresh index // TODO: revise this
            while (next_spike_time < t && synapse->next_spike != synapse->last_spike){
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
                next_spike_time = synapse->l_spike_times[synapse->next_spike];
            }

            // process input spike if required
            if(next_spike_time == t){
                
                // sum weight to input current to next update the membrane potential
                input_current += synapse->w;

                // update next spike index
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        // compute membrane potential
        lif_neuron->v = lif_neuron->v + (-(lif_neuron->v - lif_neuron->v_rest) + (lif_neuron->r * input_current)) * (1 / 1);
    

        // fire an spike if neuron membrane potential is higher than the threshold and neuron is not in refractory period
        if(lif_neuron->v >= lif_neuron->v_tresh){

            #ifdef DEBUG
                printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
            #endif

            // send spike to all output synapses
            for(i = 0; i<lif_neuron->n_output_synapse; i++){
                
                // get synapse to add the new spike
                synapse_index = lif_neuron->output_synapse_indexes[i];
                synapse = &(snn->synapses[synapse_index]);

                #ifdef DEBUG
                    printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
                #endif

                // add the spike to output synapse
                synapse->l_spike_times[synapse->last_spike] = t + synapse->delay; // the fired spikes will be computed in t + delay
                synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes; // update index of the position to store the last spike
            }

            // update control information
            lif_neuron->t_last_spike = t; // last spike generated by the neuron
            lif_neuron->r_time_rest = lif_neuron->r_time; // set refractory time period
            lif_neuron->v = lif_neuron->v_reset; // reset potential

            // add information to results struct // TODO: This should be refactorized since this will be done for all neuron types
            results->generated_spikes[neuron_id][t] = '|'; // TODO: probably this should be a list of unsigned int, or bits, or something
            results->n_spikes_per_neuron[neuron_id] += 1; 
        }
        // if the neuron has not fired an spike, indicate in the results structure
        else{
            // no spike generated
            results->generated_spikes[neuron_id][t] = ' ';
        }
    }

    // update refractory period time
    else{
        // refresh refractory period time
        lif_neuron->r_time_rest --; // the value can be lower than 0
    }
}

void initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists, int n_input_synapse, int n_output_synapse){
 
    int i;
    lif_neuron_t *neuron;
    
    // get neuron from neurons array
    neuron = &(snn->lif_neurons[neuron_index]); 

    // initialize neuron parameters from array // TODO: it's not totally correct, i guess
    neuron->v_tresh = lists->v_thres_list[neuron_index];
    neuron->v_rest = lists->v_rest_list[neuron_index]; // this or the next one?
    neuron->v_reset = lists->v_rest_list[neuron_index];
    neuron->v= neuron->v_rest; 
    neuron->r = lists->R_list[neuron_index];
    neuron->excitatory = lists->neuron_excitatory[neuron_index];
    neuron->r_time_rest = 0;
    neuron->r_time = lists->r_time_list[neuron_index];

    // check if neuron is input/output neuron 
    if(neuron_index < snn->n_input)
        neuron->is_input_neuron = 1;
    else
        neuron->is_input_neuron = 0;

    if(neuron_index >= (snn->n_neurons - snn->n_output))
        neuron->is_output_neuron = 1;
    else
        neuron->is_output_neuron = 0;


    // TODO: TEMPORAL SOLUTION; TODO BETTER IMPLEMENTATION. This should be 0 only for input synpases,
    // but I don't want to add an IF in the executed function as that will make the execution less
    // efficient
    if(neuron->is_input_neuron == 1 || neuron->is_output_neuron == 1)
        neuron->r_time = 0; // TODO: Input neurons do not have refractary time. Is this correct? I'm not sure
    
    // reserve memory to store input and output synapses indexes
    neuron->input_synapse_indexes = malloc(n_input_synapse * sizeof(int));
    neuron->output_synapse_indexes = malloc(n_output_synapse * sizeof(int));
    
    // store number of input and output synpases for neuron
    neuron->n_input_synapse = n_input_synapse;
    neuron->n_output_synapse = n_output_synapse;

    // initialize control variables
    neuron->next_input_synapse = 0; // index that indicate the position of the next spike to read
    neuron->next_output_synapse = 0; // index that indicate where the next spike must be write
    neuron->t_last_spike = -1; // time step when the neuron fired the last spike
}

void re_initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists){
    
    lif_neuron_t *neuron;
    
    // get neuron from neurons array
    neuron = &(snn->lif_neurons[neuron_index]); 

    // initialize neuron parameters from array // TODO: I think some parameters are not necessary
    neuron->v_tresh = lists->v_thres_list[neuron_index];
    neuron->v_rest = lists->v_rest_list[neuron_index]; // this or the next one?
    neuron->v_reset = lists->v_rest_list[neuron_index];
    neuron->v= neuron->v_rest; 
    neuron->r = lists->R_list[neuron_index];
    neuron->excitatory = lists->neuron_excitatory[neuron_index];
    neuron->r_time_rest = 0;
    neuron->r_time = lists->r_time_list[neuron_index];
    
    // reinitialize control parameters
    neuron->next_input_synapse = 0; 
    neuron->next_output_synapse = 0;
    neuron->t_last_spike = -1;
}

void add_input_synapse_to_lif_neuron(lif_neuron_t *neuron, synapse_t* synapse, int synapse_index){
    
    // add the synapse index to the list of the neuron
    neuron->input_synapse_indexes[neuron->next_input_synapse] = synapse_index;
    neuron->next_input_synapse += 1; // control parameter for initialization

    // add reference to the neuron in the synapse
    synapse->post_synaptic_lif_neuron = neuron;
}

void add_output_synapse_to_lif_neuron(lif_neuron_t *neuron, synapse_t *synapse, int synapse_index){
    
    // add the synapse index to the list of the neuron
    neuron->output_synapse_indexes[neuron->next_output_synapse] = synapse_index;
    neuron->next_output_synapse += 1;

    // add reference to the neuron in the synapse
    synapse->pre_synaptic_lif_neuron = neuron;
}
