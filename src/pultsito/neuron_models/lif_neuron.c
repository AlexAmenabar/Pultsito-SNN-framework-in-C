#include "snn_library.h"
#include "neuron_models/lif_neuron.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>


void lif_neuron_compute_input_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    lif_neuron_t *lif_neuron, *pre_lif_neuron;
    synapse_t *synapse;
    int i, next_spike_time, synapse_index, delay, msb; 
    double I = 0, w;


    // get neuron to be processed
    lif_neuron = &(snn->lif_neurons[neuron_id]);
    

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    //msb = lif_neuron->r_time_rest & (1 << (sizeof(int) * 8 - 1)); // check if positive

    // process input spikes for the neuron if not in refractory period
    if(lif_neuron->r_time_rest <= 0){
        
        // loop over input synapses
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            // get synapse from synapse array
            synapse_index = lif_neuron->input_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]); // TODO: make a copy???
            pre_lif_neuron = synapse->pre_synaptic_lif_neuron;

            w = synapse->w;
            delay = synapse->delay;

            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            
            // get the time step of the next spike to be processed
            next_spike_time = pre_lif_neuron->spike_times_arr[lif_neuron->next_spike_index[i]] + delay;

            // refresh index
            while (next_spike_time < t && lif_neuron->next_spike_index[i] != pre_lif_neuron->last_spike){

                lif_neuron->next_spike_index[i] = (lif_neuron->next_spike_index[i] + 1) % pre_lif_neuron->max_spikes;
                next_spike_time = pre_lif_neuron->spike_times_arr[lif_neuron->next_spike_index[i]] + delay;
            }

            // process input spike if the spike time + the delay is equal to the actual t
            if((next_spike_time) == t && next_spike_time - delay != -1){
                I += w;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        // compute membrane potential --> https://colab.research.google.com/github/johanjan/MOOC-HPFEM-source/blob/master/LIF_ei_balance_irregularity.ipynb
        // lif_neuron->v = lif_neuron->v + (-(lif_neuron->v - lif_neuron->v_rest) + (lif_neuron->r * input_current)) * (1 / 1);
        //lif_neuron->v =  lif_neuron->v * (1 - 1 / 20) + input_current;  //(0.2) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current); // (1 / 5)
        // https://unaterzavia.com/neural-dynamics2/
        lif_neuron->v = (1 - 0.05) * lif_neuron->v + lif_neuron->v_rest * 0.05 + I; // * lif_neuron->r * 1/20; // supposing r * 1/20 == 1   
    }
}

void lif_neuron_compute_output_synapses(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    // get neuron to be processed
    lif_neuron_t *lif_neuron = &(snn->lif_neurons[neuron_id]);

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    // fire an spike if neuron membrane potential is higher than the threshold and neuron is not in refractory period
    if(lif_neuron->v >= lif_neuron->v_tresh){ // if the neuron is in refractory period is impossible to have a higher v value than the threshold, so it is not necessary to indicate it

        #ifdef DEBUG
            printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
        #endif

        // add the spike to output synapse
        lif_neuron->spike_times_arr[lif_neuron->last_spike] = t;// + synapse->delay;
        lif_neuron->last_spike = (lif_neuron->last_spike + 1) % lif_neuron->max_spikes;
        
        // update control information
        lif_neuron->t_last_spike = t; // last spike generated by the neuron
        lif_neuron->r_time_rest = lif_neuron->r_time; // set refractory time period
        lif_neuron->v = lif_neuron->v_rest; // reset potential

        // add information to results struct // TODO: This should be refactorized since this will be done for all neuron types
        results->generated_spikes[neuron_id][t] = '|'; // TODO: probably this should be a list of unsigned int, or bits, or something
        results->n_spikes_per_neuron[neuron_id] += 1; 
    }
    else{
        // no spike generated
        results->generated_spikes[neuron_id][t] = ' ';

        // refresh refractory period time
        lif_neuron->r_time_rest --; // the value can be lower than 0, so no problem
    }
}

void lif_neuron_step(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){

    lif_neuron_t *lif_neuron, *pre_lif_neuron;
    synapse_t *synapse;
    int i, next_spike_time, synapse_index, delay, msb; //pre_neuron_index; 
    double I = 0, w;


    // get neuron to be processed
    lif_neuron = &(snn->lif_neurons[neuron_id]);
    

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif

    //msb = lif_neuron->r_time_rest & (1 << (sizeof(int) * 8 - 1)); // check if positive

    // process input spikes for the neuron if not in refractory period
    if(lif_neuron->r_time_rest <= 0){
        
        // loop over input synapses
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            // get synapse from synapse array
            synapse_index = lif_neuron->input_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]); // TODO: make a copy???
            pre_lif_neuron = synapse->pre_synaptic_lif_neuron;
            //pre_neuron_index = synapse->pre_neuron_index;

            w = synapse->w;
            delay = synapse->delay;

            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            
            // get the time step of the next spike to be processed
            next_spike_time = pre_lif_neuron->spike_times_arr[lif_neuron->next_spike_index[i]] + delay;

            // refresh index
            while (next_spike_time < t && lif_neuron->next_spike_index[i] != pre_lif_neuron->last_spike){

                lif_neuron->next_spike_index[i] = (lif_neuron->next_spike_index[i] + 1) % pre_lif_neuron->max_spikes;
                next_spike_time = pre_lif_neuron->spike_times_arr[lif_neuron->next_spike_index[i]] + delay;
            }

            // process input spike if the spike time + the delay is equal to the actual t
            if((next_spike_time) == t && next_spike_time - delay != -1){
                I += w;
            }

            #ifdef DEBUG
                printf("\n");
            #endif

            // add sync
            //snn->sync[pre_neuron_index]++;
        }

        // compute membrane potential --> https://colab.research.google.com/github/johanjan/MOOC-HPFEM-source/blob/master/LIF_ei_balance_irregularity.ipynb
        // lif_neuron->v = lif_neuron->v + (-(lif_neuron->v - lif_neuron->v_rest) + (lif_neuron->r * input_current)) * (1 / 1);
        //lif_neuron->v =  lif_neuron->v * (1 - 1 / 20) + input_current;  //(0.2) * (-(lif_neuron->v - lif_neuron->v_rest) + lif_neuron->r * input_current); // (1 / 5)
        // https://unaterzavia.com/neural-dynamics2/
        lif_neuron->v = (1 - 0.05) * lif_neuron->v + lif_neuron->v_rest * 0.05 + I; // * lif_neuron->r * 1/20; // supposing r * 1/20 == 1   


        // fire an spike if neuron membrane potential is higher than the threshold and neuron is not in refractory period
        if(lif_neuron->v >= lif_neuron->v_tresh){ // if the neuron is in refractory period is impossible to have a higher v value than the threshold, so it is not necessary to indicate it

            #ifdef DEBUG
                printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
            #endif

            // add the spike to output synapse
            lif_neuron->spike_times_arr[lif_neuron->last_spike] = t;// + synapse->delay;
            lif_neuron->last_spike = (lif_neuron->last_spike + 1) % lif_neuron->max_spikes;
            
            // update control information
            lif_neuron->t_last_spike = t; // last spike generated by the neuron
            lif_neuron->r_time_rest = lif_neuron->r_time; // set refractory time period
            lif_neuron->v = lif_neuron->v_rest; // reset potential

            // add information to results struct // TODO: This should be refactorized since this will be done for all neuron types
            results->generated_spikes[neuron_id][t] = '|'; // TODO: probably this should be a list of unsigned int, or bits, or something
            results->n_spikes_per_neuron[neuron_id] += 1; 
        }
        else{
            // no spike generated
            results->generated_spikes[neuron_id][t] = ' ';

            // refresh refractory period time
            lif_neuron->r_time_rest --; // the value can be lower than 0, so no problem
        }
    }
    else{
        // no spike generated
        results->generated_spikes[neuron_id][t] = ' ';

        // refresh refractory period time
        lif_neuron->r_time_rest --; // the value can be lower than 0, so no problem
    }
}



/*
void lif_neuron_step(spiking_nn_t *snn, int t, int neuron_id, simulation_results_per_sample_t *results){
    
    lif_neuron_t *lif_neuron;
    int i, next_spike_time, synapse_index;
    double input_current = 0;
    synapse_t *synapse;

    lif_neuron = &(snn->lif_neurons[neuron_id]);

    #ifdef DEBUG
        printf(" - Processing neuron %d \n", neuron_id);
    #endif


    // process neuron if not in refractory period
    if(lif_neuron->r_time_rest <= 0){ 
        
        // loop over input synapses
        for(i=0; i<lif_neuron->n_input_synapse; i++)
        {
            // get synapse from synapse array
            synapse_index = lif_neuron->input_synapse_indexes[i];
            synapse = &(snn->synapses[synapse_index]);


            #ifdef DEBUG
                printf(" -- Processing input synapse %d: ", synapse_index);
            #endif

            // get the time step of the next spike to be processed
            next_spike_time = synapse->l_spike_times[synapse->next_spike];

            // refresh index // TODO: revise this
            while (next_spike_time < t && synapse->next_spike != synapse->last_spike){
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
                next_spike_time = synapse->l_spike_times[synapse->next_spike];
            }

            // process input spike if required
            if(next_spike_time == t){
                
                // sum weight to input current to next update the membrane potential
                input_current += synapse->w;

                // update next spike index
                synapse->next_spike = (synapse->next_spike + 1) % synapse->max_spikes;
            }

            #ifdef DEBUG
                printf("\n");
            #endif
        }

        // compute membrane potential
        lif_neuron->v = lif_neuron->v + (-(lif_neuron->v - lif_neuron->v_rest) + (lif_neuron->r * input_current)) * (1 / 1);
    

        // fire an spike if neuron membrane potential is higher than the threshold and neuron is not in refractory period
        if(lif_neuron->v >= lif_neuron->v_tresh){

            #ifdef DEBUG
                printf(" -- Spike generated by %d at time %d\n", neuron_id, t);
            #endif

            // send spike to all output synapses
            for(i = 0; i<lif_neuron->n_output_synapse; i++){
                
                // get synapse to add the new spike
                synapse_index = lif_neuron->output_synapse_indexes[i];
                synapse = &(snn->synapses[synapse_index]);

                #ifdef DEBUG
                    printf(" --- Processing output synapse %d: spike located for time %d\n", synapse_index, t + synapse->delay);
                #endif

                // add the spike to output synapse
                synapse->l_spike_times[synapse->last_spike] = t + synapse->delay; // the fired spikes will be computed in t + delay
                synapse->last_spike = (synapse->last_spike + 1) % synapse->max_spikes; // update index of the position to store the last spike
            }

            // update control information
            lif_neuron->t_last_spike = t; // last spike generated by the neuron
            lif_neuron->r_time_rest = lif_neuron->r_time; // set refractory time period
            lif_neuron->v = lif_neuron->v_rest; // reset potential

            // add information to results struct // TODO: This should be refactorized since this will be done for all neuron types
            results->generated_spikes[neuron_id][t] = '|'; // TODO: probably this should be a list of unsigned int, or bits, or something
            results->n_spikes_per_neuron[neuron_id] += 1; 
        }
        // if the neuron has not fired an spike, indicate in the results structure
        else{
            // no spike generated
            results->generated_spikes[neuron_id][t] = ' ';
        }
    }

    // update refractory period time
    else{
        // refresh refractory period time
        lif_neuron->r_time_rest --; // the value can be lower than 0
    }
}
*/
void initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists, int n_input_synapse, int n_output_synapse){
 
    int i;
    lif_neuron_t *neuron;

    // get neuron from neurons array
    neuron = &(snn->lif_neurons[neuron_index]); 

    // initialize neuron parameters from array // TODO: it's not totally correct, i guess
    neuron->v_tresh = lists->v_thres_list[neuron_index];
    neuron->v_rest = lists->v_rest_list[neuron_index]; // this or the next one?
    neuron->v = neuron->v_rest; 
    neuron->r = lists->R_list[neuron_index];
    neuron->excitatory = lists->neuron_excitatory[neuron_index];
    neuron->r_time_rest = -1;
    neuron->r_time = lists->r_time_list[neuron_index];

    // check if neuron is input
    if(neuron_index < snn->n_input)
        neuron->is_input_neuron = 1;
    else
        neuron->is_input_neuron = 0;

    // check if neuron is output
    if(neuron_index >= (snn->n_neurons - snn->n_output))
        neuron->is_output_neuron = 1;
    else
        neuron->is_output_neuron = 0;


    // TODO: I think this does not make sense, so I will remove it
    // TODO: TEMPORAL SOLUTION; TODO BETTER IMPLEMENTATION. This should be 0 only for input synpases,
    // but I don't want to add an IF in the executed function as that will make the execution less
    // efficient
    //if(neuron->is_input_neuron == 1 || neuron->is_output_neuron == 1)
    //    neuron->r_time = 0; // TODO: Input neurons do not have refractary time. Is this correct? I'm not sure
    

    // reserve memory to store input and output synapses indexes
    neuron->input_synapse_indexes = malloc(n_input_synapse * sizeof(int));
    neuron->output_synapse_indexes = malloc(n_output_synapse * sizeof(int));
    
    // store number of input and output synpases for each neuron
    neuron->n_input_synapse = n_input_synapse;
    neuron->n_output_synapse = n_output_synapse;

    // initialize control variables
    neuron->next_input_synapse = 0; // index that indicate the position of the next spike to read
    neuron->next_output_synapse = 0; // index that indicate where the next spike must be write
    neuron->t_last_spike = -1; // time step when the neuron fired the last spike


    // spike array
    neuron->last_spike = 0; 
    neuron->next_spike_index = (int *)malloc(n_input_synapse * sizeof(int));
    for(i=0; i<n_input_synapse; i++){
        neuron->next_spike_index[i] = 0;
    }
    //neuron->next_spike = 0;
    /*if(neuron->is_input_neuron){
        neuron->spike_times_arr = (int *)malloc(INPUT_MAX_SPIKES * sizeof(int));
        for(i = 0; i<INPUT_MAX_SPIKES; i++)
            neuron->spike_times_arr[i] = -1; // no spikes yet
        neuron->max_spikes = INPUT_MAX_SPIKES;
    }*/
    //else{
    neuron->spike_times_arr = (int *)malloc(MAX_SPIKES * sizeof(int));
    for(i = 0; i<MAX_SPIKES; i++)
        neuron->spike_times_arr[i] = -1; // no spikes yet
    neuron->max_spikes = MAX_SPIKES;
    //}
}

void re_initialize_lif_neuron(spiking_nn_t *snn, int neuron_index, network_construction_lists_t *lists){
    
    int i;
    lif_neuron_t *neuron;
    
    // get neuron from neurons array
    neuron = &(snn->lif_neurons[neuron_index]); 

    // initialize neuron parameters from array // TODO: I think some parameters are not necessary
    neuron->v_tresh = lists->v_thres_list[neuron_index];
    neuron->v_rest = lists->v_rest_list[neuron_index]; // this or the next one?
    neuron->v= neuron->v_rest; 
    neuron->r = lists->R_list[neuron_index];
    neuron->excitatory = lists->neuron_excitatory[neuron_index];
    neuron->r_time_rest = 0;
    neuron->r_time = lists->r_time_list[neuron_index];
    
    // reinitialize control parameters
    neuron->next_input_synapse = 0; 
    neuron->next_output_synapse = 0;
    neuron->t_last_spike = -1;

    // spike array
    neuron->last_spike = 0; 
    for(i=0; i<neuron->n_input_synapse; i++){
        neuron->next_spike_index[i] = 0;
    }
}

void add_input_synapse_to_lif_neuron(spiking_nn_t *snn, int neuron_index, int synapse_index){
    
    lif_neuron_t *neuron = &(snn->lif_neurons[neuron_index]);
    synapse_t *synapse = &(snn->synapses[synapse_index]);

    // add the synapse index to the list of the neuron
    neuron->input_synapse_indexes[neuron->next_input_synapse] = synapse_index;
    neuron->next_input_synapse += 1; // control parameter for initialization

    // add reference to the neuron in the synapse
    synapse->post_synaptic_lif_neuron = neuron;
    synapse->post_neuron_index = neuron_index;
}

void add_output_synapse_to_lif_neuron(spiking_nn_t *snn, int neuron_index, int synapse_index){
    
    lif_neuron_t *neuron = &(snn->lif_neurons[neuron_index]);
    synapse_t *synapse = &(snn->synapses[synapse_index]);

    // add the synapse index to the list of the neuron
    neuron->output_synapse_indexes[neuron->next_output_synapse] = synapse_index;
    neuron->next_output_synapse += 1;

    // add reference to the neuron in the synapse
    synapse->pre_synaptic_lif_neuron = neuron;
    synapse->pre_neuron_index = neuron_index;
}

void cp_lif_neurons(spiking_nn_t *cp_snn, spiking_nn_t *or_snn){

    int i, j;
    lif_neuron_t *or_lif, *cp_lif;

    cp_snn->lif_neurons = (lif_neuron_t *)malloc(or_snn->n_neurons * sizeof(lif_neuron_t));

    for(i = 0; i<or_snn->n_neurons; i++){

        or_lif = &(or_snn->lif_neurons[i]);
        cp_lif = &(cp_snn->lif_neurons[i]);

        // synapses data
        cp_lif->n_input_synapse = or_lif->n_input_synapse;
        cp_lif->input_synapse_indexes = (int *)malloc(cp_lif->n_input_synapse * sizeof(int));
        for(j = 0; j<cp_lif->n_input_synapse; j++){
            cp_lif->input_synapse_indexes[j] = or_lif->input_synapse_indexes[j];
        }

        cp_lif->n_output_synapse = or_lif->n_output_synapse;
        cp_lif->output_synapse_indexes = (int *)malloc(cp_lif->n_output_synapse * sizeof(int));
        for(j = 0; j<cp_lif->n_output_synapse; j++){
            cp_lif->output_synapse_indexes[j] = or_lif->output_synapse_indexes[j];
        }

        cp_lif->next_spike_index = (int *)calloc(cp_lif->n_input_synapse, sizeof(int));


        // input / output
        cp_lif->is_input_neuron = or_lif->is_input_neuron;
        cp_lif->is_output_neuron = or_lif->is_output_neuron;

        // general data
        cp_lif->excitatory = or_lif->excitatory;
        cp_lif->v = or_lif->v;
        cp_lif->r = or_lif->r;
        cp_lif->v_rest = or_lif->v_rest;
        cp_lif->v_tresh = or_lif->v_tresh;
        cp_lif->r_time = or_lif->r_time;
        cp_lif->r_time_rest = or_lif->r_time_rest;
        cp_lif->t_last_spike = or_lif->t_last_spike;

        // spike array
        cp_lif->last_spike = or_lif->last_spike;
        cp_lif->max_spikes = or_lif->max_spikes;
        cp_lif->spike_times_arr = (int *)malloc(cp_lif->max_spikes * sizeof(int));
        for(j = 0; j<cp_lif->max_spikes; j++){
            cp_lif->spike_times_arr[j] = -1;
        }
    }
}